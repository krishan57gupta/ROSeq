---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    comment = "#>",
    fig.path = "man/figures/README-",
    out.width = "100%"
)
```


# ROSeq - A rank based approach to modeling gene expression

Author: Krishan Gupta

## Introduction

ROSeq - A rank based approach to modeling gene expression with filtered and 
normalized read count matrix. Takes in the complete filtered and normalized 
read count matrix, the location of the two sub-populations and 
the number of cores to be used.

## Installation

The developer version of the R package can be installed with 
the following R commands:
```r
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
BiocManager::install('ROSeq')
```
or can be installed with the following R commands:
```r
library(devtools)
install_github('krishan57gupta/ROSeq')
```
## Vignette tutorial

This vignette uses a tung dataset already inbuilt in same package, 
to demonstrate a standard pipeline. This vignette can be used 
as a tutorial as well.
Ref: Tung, P.-Y.et al.Batch effects and the effective design of 
single-cell geneexpression studies.Scientific reports7, 39921 (2017).

## Example

Libraries need to be loaded before running.


```{r setup}
library(ROSeq)
library(edgeR)
library(limma)
```

## Loading tung dataset
```{r data, message=FALSE,warning = FALSE,include=TRUE, cache=FALSE}
samples<-list()
samples$count<-ROSeq::L_Tung_single$NA19098_NA19101_count
samples$group<-ROSeq::L_Tung_single$NA19098_NA19101_group
samples$count[1:5,1:5]
```

## Data Preprocessing: cells and genes filtering then voom transformation 
## after TMM normalization
### First convert matrix to numeric values
### Then cell filtering, gene filtering
### Finally normalization and then tranformation
### Note: For filtering, normalization and tranfromation other methods can be
### used, but recomended as shown in example

```{r preprocesing, message=FALSE,warning = FALSE,include=TRUE, cache=FALSE}
gene_name<-rownames(samples$count)
samples$count<-apply(samples$count,2,function(x) as.numeric(x))
rownames(samples$count)<-rownames(samples$count)
samples$count<-samples$count[,colSums(samples$count> 0) > 2000]
gkeep<-apply(samples$count,1,function(x) sum(x>2)>=3)
samples$count<-samples$count[gkeep,]
samples$count<-limma::voom(ROSeq::TMMnormalization(samples$count))
```

## ROSeq calling
### Requires a matrix with row as genes and columns  and cells
### condition of cells, means lables for each cell
### numCores can be set as per number of core/cpu avaialble
```{r main, message=FALSE,warning = FALSE, include=TRUE, cache=FALSE}
output<-ROSeq(countData=samples$count, condition = samples$group, numCores=1)
```

## Showing results are in the form of pVals, pAdj and log2FC
### p_Vals : p_value (unadjusted)
### p_Adj : Adjusted p-value, based on FDR method
### log2FC : log fold-chage of the average expression between the two groups,
### Positive values show feature is highly enriched in the first group.
```{r output, message=FALSE,warning = FALSE,include=TRUE, cache=FALSE}
output[1:5,]
```
